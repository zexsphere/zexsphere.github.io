<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Zex</title><link>/post/</link><description>Recent content in Posts on Zex</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 17 Aug 2023 11:04:38 +0800</lastBuildDate><atom:link href="/post/atom.xml" rel="self" type="application/rss+xml"/><item><title>CMake components - use Doxygen</title><link>/post/0007/</link><pubDate>Thu, 17 Aug 2023 11:04:38 +0800</pubDate><guid>/post/0007/</guid><description>该图片由 Raka C. 在 Pixabay 上发布
Doxygen 使用流程 1. 生成配置 $ doxygen -g Doxyfile.in 2. 修改配置 根据需要修改 Doxyfile.in 里的选项
# Project related configuration options DOXYFILE_ENCODING = UTF-8 PROJECT_NAME = &amp;#34;My Project&amp;#34; PROJECT_NUMBER = v0.1.0 PROJECT_BRIEF = &amp;#34;a research project&amp;#34; PROJECT_LOGO = OUTPUT_DIRECTORY = doc/ ALLOW_UNICODE_NAMES = NO OUTPUT_LANGUAGE = English OPTIMIZE_OUTPUT_FOR_C = YES # Configuration options related to the input files INPUT = @PROJECT_SOURCE_DIR@ RECURSIVE = YES EXCLUDE = @PROJECT_SOURCE_DIR@/etc @PROJECT_SOURCE_DIR@/build USE_MDFILE_AS_MAINPAGE = @PROJECT_SOURCE_DIR@/README.</description></item><item><title>Intro to Tun/Tap</title><link>/post/0006/</link><pubDate>Thu, 10 Aug 2023 09:54:51 +0800</pubDate><guid>/post/0006/</guid><description>该图片由 Simon Oberthaler 在 Pixabay 上 发布
原理 +---------------+ +---------------+ +---------------+ | application A | | application B | | application C | +-------^-------+ +-------+-------+ +-------+-------+ user-mode | | | +-----------------------------------------------------------------------------------+ | | | | +-------v-------------------------v-------+ kernel-mode | | layer socket | | +--------------------^--------------------+ | | | +--------------------v--------------------+ | | TCP/IP stack | | +--------^-----------------------^--------+ | | | +-------v-------+ +--------v--------+ +--------v--------+ | /dev/net/tun | | Drivers for | | Drivers for | | char drivers| | virtual NIC | | pysical NIC | +-------^-------+ +--------^--------+ +--------^--------+ | | | | +--------v--------+ +--------v--------+ | (tun tap)| virtual NIC | | pysical NIC | | +--------^--------+ +--------^--------+ | | | | | | +--------------------------+ | | +-----------------------------------------------------------------------------------+ | +--------------+ | | Internet &amp;lt;-----+ +--------------+ 实践 code #include &amp;lt;linux/if.</description></item><item><title>Self-hosting services using the nginx ssl proxy</title><link>/post/0005/</link><pubDate>Mon, 07 Aug 2023 10:57:10 +0800</pubDate><guid>/post/0005/</guid><description>该图片由 Pete Linforth 在 Pixabay 上发布
结构图 基础点 容器可以加入同一个网络中，并相互通过容器名通信 expect 可以用脚本自动化控制命令行下程序与用户的交互 步骤 1. 生成自签名证书 openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 2. 配置 nginx.conf server { listen 11443 ssl; server_name localhost; ssl_certificate /usr/local/nginx/certs/cert.pem; ssl_certificate_key /usr/local/nginx/certs/key.pem; location / { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://web:80; } # ...... } # server { # 新增 Web 服务 # ... # } 3. expect 脚本 # pem.</description></item><item><title>Solve Common Memory Problems Using Dynamic Analysis Tools</title><link>/post/0004/</link><pubDate>Sun, 06 Aug 2023 15:52:05 +0800</pubDate><guid>/post/0004/</guid><description>该图片由 Jürgen 在 Pixabay 上 发布
c/c++ 可使用检测工具asan valgrind定位程序问题。一般的检查，asan 比 valgrind 更快，结果更精确，经过 time 测试，asan 消耗时间是 valgrind 的 1/30。
环境 valgrind（3.21.0） gcc(13.1.1) 用法 Sanitizer 编译时附带 -fsanitize=address -g 直接执行程序 Valgrind 编译时附带 -g 使用 Valgrind 执行程序 valgrind --tool=memcheck --leak-check=full ./a.out 触发类型 内存问题 memory leak
char *str = (char *)malloc(100 * sizeof(char)); strcpy(str, &amp;#34;Hello Leak!&amp;#34;); printf(&amp;#34;%s\n&amp;#34;, str); /** leak here */ return 0; double free
char *str = (char *)malloc(100 * sizeof(char)); free(str); /** double free */ free(str); return 0; use after free</description></item><item><title>Work With An Efficient Environment</title><link>/post/0003/</link><pubDate>Sun, 06 Aug 2023 09:08:47 +0800</pubDate><guid>/post/0003/</guid><description>该图片由 Gauthier Pous 在 Pixabay 上 发布
经验分享 文本编辑器 - vim Vim 是高度可配置的，然而定制是一件很个性化的事情，因此我试图避免建议什么应该放进你的 vimrc 里，什么不应该。相反，本书关注的是 Vim 编辑器的核心功能。不管你是通过 SSH 登录远端服务器工作，还是在用本地安装了插件而增添了额外功能的 GVim，这些功能都永远在那儿。精通了 Vim 的核心功能，你就获得了一个可移植的、强大的文本编辑工具。
之前求快，学人将 Vim 打造成 IDE，上一堆插件，改键盘映射；又学人将 NVim 打造成 IDE，上一堆插件，改键盘映射。常常插件一更新，一堆报错，又去看文档，修报错。折腾来折腾去，唯独专业知识没学上几分。
就此老实了，写代码该用 IDE 就用 IDE，慢慢理解 Vim 核心功能才是正道。
练习 vimtutor (20min)
实践 vim 实用技巧
根据需要编写 vimscript
Slow is Smooth, and Smooth is Fast.
交互式shell - zsh zsh 功能很强大，最基础的命令行历史补全，解脱重复工作。
配置 ohmyzsh # ~/.zshrc plugins=( git # git 命令缩写 zsh-autosuggestions # 命令行补全 # ... https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins ) # 不要忘了 source ～/.</description></item><item><title>SVN Command Line Usage With Docker</title><link>/post/0002/</link><pubDate>Sat, 05 Aug 2023 08:22:28 +0800</pubDate><guid>/post/0002/</guid><description>该图片由 Gerd Altmann 在 Pixabay 上发布
Self-Hosted SVN 服务属于 IO 密集型任务。相比于 Git，更适合于频繁进行大型二进制文件的存取。且内存占用极低，从自搭建情况看，一般在 3MB 左右，峰值传输 20MB 左右。
Server with docker 安装服务 docker compose up -d # docker-compose.yaml version: &amp;#39;3.3&amp;#39; services: svn-server: image: garethflowers/svn-server container_name: svn-server volumes: - &amp;#39;/svn:/var/opt/svn&amp;#39; ports: - &amp;#39;3690:3690&amp;#39; 生成仓库 docker exec -it svn-server svnadmin create repo
配置仓库账户文件 位于 ^/repo/conf/{svnserver.conf passwd authz}
# svnserver.conf anon-access = none # 非注册用户权限 auth-access = write # 注册用户权限 password-db = passwd # 密码文件路径 authz-db = authz # 权限文件路径 # passwd user = password # 填写用户名密码注册 # authz [repo:/path] user = rw # 设置用户名拥有的仓库路径权限 Client 安装客户端 sudo pacman -S subversion 拉取服务端仓库 svn checkout svn://path 其余命令用到再查 svn -h Usage 我是为了这点醋，才包的这顿饺子</description></item><item><title>reading notes for *How to Read a Book* (1)</title><link>/post/0001/</link><pubDate>Tue, 04 Jul 2023 22:10:57 +0800</pubDate><guid>/post/0001/</guid><description>该图片由Mirosław i Joanna Bucholc在Pixabay上 发布
将读书的主要目的当作是增进自身理解能力的人，被称作“阅读的人（readers）”。
脉络 信息时代海量的资讯阻碍了理解力，对增进世界的了解没有带来实质的帮助。接收者每天得到的是他人打包好的态度和观点，长此以往，自我思考的道路将不可避免地持续荒芜。
阅读者，要亲手拿回逐渐被忽视的能力，像鲁迅先生在 拿来主义 里说的那样，“我们要运用脑髓，放出眼光，自己来拿！”
而面对书本这个无声的老师，就要懂得如何让书本教导我们。
摘抄 太多的资讯就如同太少的资讯一样，都是一种对理解力的阻碍。换句话说，现代的媒体正以压倒性的泛滥资讯阻碍了我们的理解力。
计算机行业各种应用术语、互联网的黑话,也是一种对理解力的障碍。用术语扯上半小时的事情，可能用大白话五分钟就能说清。在太多的信息面前没有分析消化，将术语当作虎皮大衣，或许是一种对自身理解力的放弃。
电视观众、收音机听众、杂志读者所面对的是一种复杂的组成——从独创的华丽辞藻到经过审慎挑选的资料与统计——目的都在让人不需要面对困难或努力，很容易就整理出“自己”的思绪。但是这些精美包装的资讯效率实在太高了，让观众、听众或读者根本用不着自己做结论。相反的，他们直接将包装过后的观点装进自己的脑海中，就像录影机愿意接受录影带一样自然。他只要按一个“倒带”的钮，就能找到他所需要的适当言论。
这段话想起了《抢钱夫妻》里那个著名片段。
这个读者比另一个读者更主动一些，他在阅读世界里面的探索能力就更强一些，收获更多一些，因而也更高明一些。读者对他自己，以及自己面前的书籍，要求的越多，获得的就越多。
还是鲁迅先生的话，“总之，我们要拿来。”
只有一种方式是真正地在阅读。没有任何外力的帮助，你就是要读这本书。你什么都没有，只凭着内心的力量，玩味着眼前的字句，慢慢地提升自己，从只有模糊的概念到更清楚地理解为止。这样的一种提升，是在阅读时的一种脑力活动，也是更高的阅读技巧。这种阅读就是让一本书向你既有的理解力做挑战。
将书里的信息挑重点摘出来，弄成漂亮点的思维导图，是轻松和容易的，也常常给人一种已掌握的幻象。毕竟应试教育的训练下，下意识去找考点，然后花大力气去背和刷题已经成了习惯。但这在掌握原理上已经走上歧路，我无比赞同纪录片 Are Our Kids Tough Enough? Chinese School 里英国教师的观点，“中式学校肯定会失败的，而且是惨败。”
这里的“学习”指的是理解更多的事情，而不是记住更多的资讯。
中式教育必将惨败。
蒙田说：“初学者的无知在于未学，而学者的无知在于学后。”第一种的无知是连字母都没学过，当然无法阅读。第二种的无知却是读错了许多书。英国诗人亚历山大·蒲伯（Alexander Pope）称这种人是书呆子，无知的阅读者。总有一些书呆子读得太广，却读不通。希腊人给这种集阅读与愚蠢于一身的人一种特别称呼，这也可运用在任何年纪、好读书却读不懂的人身上。他们就叫“半瓶醋”（Sophomores）。
“有些常识的人都会记得，眼睛的困惑有两种，也来自两种起因，不是因为走出光明，就是因为走进光明所致，不论是人体的眼睛或是心灵的眼睛，都是如此。” 第一阶段：原来有这个。第二阶段：原来是这样。跨过第一阶段的人很多，达到第二阶段的人很少。跨过第一阶段的人而没有到达第二阶段的人常常会产生傲慢心而停留，回身嘲讽那些“无知”的人“没有见过世面”。唉，我们怎么会被置于如此滑稽的境地啊。
其实，任何学习都不该没有活力，就像任何阅读都不该死气沉沉。
但如果你追寻的是一种解释，你就必须去理解它，否则没有人能向你解释清楚。更进一步来说，一位活生生的老师出现在你眼前时，你从了解他所说的话，来提升理解力。而如果一本书就是你的老师的话，你就得一切靠自己了。
想法 chapter 1 读下来，观点和 Amusing Ourselves to Death 是一脉相承的，后者在篇幅上深度剖析了这种现象。那么本书提供了一种让自身摆脱其情境的方法，在阅读中尝试去掌握更深一层的理解，一次又一次去推进理解力。
自打 ChatGPT 出来后，对它的依赖程度越来越高。有时也会想，是不是以后只需要发号施令就行了。因为很多情况下，ChatGPT 能够很好的辅助工作，让人轻松不少。毕竟人不是机器，冗杂的工作是反人性的。但长时间让工具去代替思维，自己得不到成长也是件令人惋惜的事情。因此有必要进行判断，对自身毫无成长的、一眼看透的冗杂工作，丢给 ChatGPT 吧，其余的尽管多费费心思。</description></item></channel></rss>