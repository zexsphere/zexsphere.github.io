<!doctype html><html lang=en><head><meta charset=utf-8><meta name=referrer content="same-origin"><title>Solve Common Memory Problems Using Dynamic Analysis Tools :: Zex</title><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="该图片由 Jürgen 在 Pixabay 上 发布
c/c++ 可使用检测工具asan valgrind定位程序问题。一般的检查，asan 比 valgrind 更快，结果更精确，经过 time 测试，asan 消耗时间是 valgrind 的 1/30。
环境 valgrind（3.21.0） gcc(13.1.1) 用法 Sanitizer 编译时附带 -fsanitize=address -g 直接执行程序 Valgrind 编译时附带 -g 使用 Valgrind 执行程序 valgrind --tool=memcheck --leak-check=full ./a.out 触发类型 内存问题 memory leak
char *str = (char *)malloc(100 * sizeof(char)); strcpy(str, &amp;#34;Hello Leak!&amp;#34;); printf(&amp;#34;%s\n&amp;#34;, str); /** leak here */ return 0; double free
char *str = (char *)malloc(100 * sizeof(char)); free(str); /** double free */ free(str); return 0; use after free"><meta name=keywords content=","><meta name=robots content="noodp"><link rel=canonical href=/post/0004/><link rel=stylesheet href=/assets/style.min.css?d41d8cd98f00b204e9800998ecf8427e><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/favicon/apple-icon-precomposed.png><link rel="shortcut icon" href=/img/favicon/orange.png><meta name=twitter:card content="summary"><meta property="og:type" content="article"><meta property="og:title" content="Solve Common Memory Problems Using Dynamic Analysis Tools :: Zex"><meta property="og:description" content="一般问题尽量避免断点调试"><meta property="og:url" content="/post/0004/"><meta property="og:site_name" content="Zex"><meta property="og:image" content="https://pic.imgdb.cn/item/64cf95921ddac507ccbe4883.jpg"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2023-08-06 15:52:05 +0800 +0800"></head><body><div class="container center headings--one-size"><header class=header style=background-image:url(/img/mountain/mountains-g47d3aaa15_1280.jpg);background-position:50%;background-repeat:no-repeat;background-size:cover><div class=header__inner><div class=header__logo><a href=/><div class=logo>Zex</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/archive>Archive</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/archive>Archive</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title>Solve Common Memory Problems Using Dynamic Analysis Tools</h1><div class=post-meta><span class=post-date>2023-08-06</span>
<span class=post-author>::
zexsphere</span></div><span class=post-tags>#<a href=/tags/debug/>debug</a>&nbsp;
#<a href=/tags/c/c++/>c/c++</a>&nbsp;</span>
<img src=https://pic.imgdb.cn/item/64cf95921ddac507ccbe4883.jpg class=post-cover><div class=post-content><div><p>该图片由 Jürgen 在 Pixabay 上
<a href=https://pixabay.com/zh/photos/ladybug-beetle-leaf-insect-bug-6364312/>发布</a></p><p>c/c++ 可使用检测工具<code>asan</code> <code>valgrind</code>定位程序问题。一般的检查，asan 比 valgrind 更快，结果更精确，经过 <code>time</code> 测试，asan 消耗时间是 valgrind 的 1/30。</p><h2 id=环境>环境<a href=#环境 class=hanchor arialabel=Anchor>⚓</a></h2><ul><li>valgrind（3.21.0）</li><li>gcc(13.1.1)</li></ul><h2 id=用法>用法<a href=#用法 class=hanchor arialabel=Anchor>⚓</a></h2><ul><li>Sanitizer 编译时附带 <code>-fsanitize=address -g</code> 直接执行程序</li><li>Valgrind 编译时附带 <code>-g</code> 使用 Valgrind 执行程序 <code>valgrind --tool=memcheck --leak-check=full ./a.out</code></li></ul><h2 id=触发类型>触发类型<a href=#触发类型 class=hanchor arialabel=Anchor>⚓</a></h2><h3 id=内存问题>内存问题<a href=#内存问题 class=hanchor arialabel=Anchor>⚓</a></h3><ul><li><p>memory leak</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>str</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=mi>100</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nf>strcpy</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=s>&#34;Hello Leak!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/** leak here */</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span></code></pre></div></li><li><p>double free</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>str</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=mi>100</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nf>free</span><span class=p>(</span><span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/** double free */</span>
</span></span><span class=line><span class=cl><span class=nf>free</span><span class=p>(</span><span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span></code></pre></div></li><li><p>use after free</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>str</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=mi>100</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nf>free</span><span class=p>(</span><span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/** use after free */</span>
</span></span><span class=line><span class=cl><span class=nf>strcpy</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=s>&#34;Hello Leak!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span></code></pre></div></li><li><p>heap buffer overflow</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>str</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>)</span> <span class=o>*</span> <span class=mi>12</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/* heap-buffer-overflow */</span>
</span></span><span class=line><span class=cl><span class=nf>strcpy</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=s>&#34;Hello World!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;string is :%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>free</span><span class=p>(</span><span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span></code></pre></div></li><li><p>stack buffer overflow</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>str</span><span class=p>[</span><span class=mi>100</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=cm>/** stack-buffer-overflow */</span>
</span></span><span class=line><span class=cl><span class=n>str</span><span class=p>[</span><span class=mi>101</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span></code></pre></div></li><li><p>global buffer overflow</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>array</span><span class=p>[</span><span class=mi>100</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=o>-</span><span class=mi>1</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* global-buffer-overflow */</span>
</span></span><span class=line><span class=cl>    <span class=n>array</span><span class=p>[</span><span class=mi>101</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li><p>alloc/dealloc mismatch</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>str</span> <span class=o>=</span> <span class=n>new</span> <span class=kt>char</span><span class=p>[</span><span class=mi>100</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=cm>/** alloc-dealloc-mismatch*/</span>  
</span></span><span class=line><span class=cl>    <span class=n>delete</span> <span class=n>str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li></ul><p>​</p><p>sanitizer 给出的信息比较直观，如 memory leak 的执行信息（类型、行数、影响）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Hello Leak!
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>=================================================================</span>
</span></span><span class=line><span class=cl><span class=o>==</span><span class=nv>212706</span><span class=o>==</span>ERROR: LeakSanitizer: detected memory leaks
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Direct leak of <span class=m>100</span> byte<span class=o>(</span>s<span class=o>)</span> in <span class=m>1</span> object<span class=o>(</span>s<span class=o>)</span> allocated from:
</span></span><span class=line><span class=cl>    <span class=c1>#0 0x7f6aa04e1359 in __interceptor_malloc /usr/src/debug/gcc/gcc/libsanitizer/asan/asan_malloc_linux.cpp:69</span>
</span></span><span class=line><span class=cl>    <span class=c1>#1 0x55c93274c1aa in main ***************************/leak.c:7</span>
</span></span><span class=line><span class=cl>    <span class=c1>#2 0x7f6aa023984f  (/usr/lib/libc.so.6+0x2384f) (BuildId: 2f005a79cd1a8e385972f5a102f16adba414d75e)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>SUMMARY: AddressSanitizer: <span class=m>100</span> byte<span class=o>(</span>s<span class=o>)</span> leaked in <span class=m>1</span> allocation<span class=o>(</span>s<span class=o>)</span>.
</span></span></code></pre></div><h3 id=线程问题附带测试>线程问题（附带测试）<a href=#线程问题附带测试 class=hanchor arialabel=Anchor>⚓</a></h3><p>多线程场景下常见的错误</p><ul><li><p>data race</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>g_var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>thread1</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>g_var</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>thread2</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>g_var</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li><p>dead lock</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>pthread_mutex_t</span> <span class=n>mutex_a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>pthread_mutex_t</span> <span class=n>mutex_b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>pthread_barrier_t</span> <span class=n>barrier</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>lock_a</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>pthread_barrier_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>barrier</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_b</span><span class=p>);</span>  <span class=cm>/* 等待 lock_b 释放*/</span>
</span></span><span class=line><span class=cl>        <span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_b</span><span class=p>);</span>        
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>lock_b</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>pthread_barrier_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>barrier</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_a</span><span class=p>);</span>  <span class=cm>/* 等待 lock_a 释放 */</span>
</span></span><span class=line><span class=cl>        <span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_a</span><span class=p>);</span>        
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex_b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li></ul><p>data race 方面，tsan 相比 valgrind 结果基本一致，但速度完胜。</p><p>dead lock 方面，valgrind 能检测出线程退出未解锁导致的死锁，对相互死锁没有办法，tsan 对死锁完全没有办法。</p><h2 id=参考>参考<a href=#参考 class=hanchor arialabel=Anchor>⚓</a></h2><ul><li><em><a href=https://github.com/google/sanitizers>Sanitizers</a></em></li></ul></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button next"><a href=/post/0003/><span class=button__text>Work With An Efficient Environment</span>
<span class=button__icon>→</span></a></span></div></div><script src=https://utteranc.es/client.js repo=zexsphere/zexsphere.github.io issue-term=pathname theme=dark-blue crossorigin=anonymous async></script><noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript></div><div class=post-toc id=post-toc><h2 class=post-toc-title></h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#环境>环境</a></li><li><a href=#用法>用法</a></li><li><a href=#触发类型>触发类型</a><ul><li><a href=#内存问题>内存问题</a></li><li><a href=#线程问题附带测试>线程问题（附带测试）</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>:: Powered by <a href=http://gohugo.io>Hugo</a> 0.115.4</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><a id=back-to-top style=display:inline-block href=javascript:void(0); onclick='window.scrollTo({top:0,behavior:"smooth"})'><span class="iconfont icon-top"></span></a>
<script src=/assets/main.js?d41d8cd98f00b204e9800998ecf8427e></script>
<script>const addCopyButtons=function(e){document.querySelectorAll("pre > code").forEach(function(t){const n=document.createElement("button");n.className="copy-code-button",n.type="button",n.innerText="Copy";const s=document.createElement("div");s.className="copy-code-button-wrap",s.appendChild(n),n.addEventListener("click",function(){e.writeText(t.innerText).then(function(){n.blur(),n.innerText="✔️",setTimeout(function(){n.innerText="Copy"},2e3)},function(){n.innerText="Error"})});const o=t.parentNode;o.insertAdjacentElement("beforebegin",s)})},loadScript=(e,t)=>{var n=document.createElement("script");n.onerror=e=>{throw new URIError("The script "+e.target.src+" didn't load correctly.")},t&&(n.onload=t),document.head.insertAdjacentElement("beforeend",n),n.src=e},loadMermaidOnNeed=()=>{document.querySelectorAll(".mermaid").length>0&&loadScript("https://cdn.jsdelivr.net/npm/mermaid@8.10.1/dist/mermaid.min.js",()=>{document.head.insertAdjacentHTML("beforeend",`<style>.mermaid svg { background-color: #dadcd8 !important; }</style>`),mermaid.initialize({startOnLoad:!1,securityLevel:"strict",logLevel:1,theme:"neutral"}),mermaid.init(),console.log("mermaid init done")})},loadPlantUMLOnNeed=()=>{let e="language-plantuml";document.querySelectorAll("[class^="+e+"]").length>0&&loadScript("https://cdn.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js",()=>{(function(){Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(e){let t=document.createElement("IMG");t.loading="lazy",t.src="http://www.plantuml.com/plantuml/svg/~1"+plantumlEncoder.encode(e.innerText),e.parentNode.insertBefore(t,e),e.style.display="none"})})(),console.log("PlantUML init done")})};window.addEventListener("load",function(){const t=document.links;for(let e=0,n=t.length;e<n;e++)t[e].hostname!=window.location.hostname&&!t[e].href.startsWith("javascript:")&&!t[e].href.startsWith("mailto:")&&(t[e].target="_blank");document.querySelectorAll("#TableOfContents li").length>0&&(document.querySelector("#post-toc").style.display="block"),document.querySelectorAll("#post-toc a").forEach(e=>{e.addEventListener("click",e=>{document.querySelectorAll("#post-toc a").forEach(e=>{e.classList.remove("active")}),e.target.classList.add("active")})}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();let t=this.getAttribute("href").substring(1);window.history.pushState({},"","#"+t),document.getElementById(t).scrollIntoView({behavior:"smooth"})})}),navigator&&navigator.clipboard&&addCopyButtons(navigator.clipboard),loadPlantUMLOnNeed(),loadMermaidOnNeed()})</script></div></body></html>